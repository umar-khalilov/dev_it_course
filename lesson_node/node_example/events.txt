Event - это некий сигнал, который сообщает о том что, что-то произошло.
Если посмотреть базовый пример: Клиент - Сервер. То при входе пользователя на сайт происходит его верификация.
Он вводит свои данные, после чего они отправляются на сервер. На это действие можно повесить обработчик
client --> EventEmitter.emit('login') --> server --> EventEmitter.on('login') --> DB
И в случае если такое произошло, отправлять запрос в базу данных для того чтобы чекнуть есть ли информация о юзере
в системе. В ответ сравнивать данные от пользователя и полученные данные client <-- .emit('logSuccess').
И по рез-ту сделать еще один обработчик, который либо даст войти либо отправит на страницу с ошибками emit('logError')
=================================================================================================================
Объект EventEmitter - диспетчер, испускатель, излучатель, выдаватель.
EventEmitter - представляет собой основной объект, реализующий работу с событиями.
Один из самых важных и широко используемых объектов в Node.js.
Сам по себе EventEmitter используется редко, в основном используются наследники этого класса.
Такие как объект запроса, объект сервера и т.д.
Этот объект был создан в основном для упрощенного создания контролируемых событий.
Большое кол-во других встроенных объектов, которые генерируют события наследуют его.

1) Первый основной метод - on(event, listener-func) - Подписка
Можно указать много функций - подписчиков и все будут вызваны в порядке очередности(сверху-вниз).
2) Второй основной метод emit(event: string | symbol, ...args:any[])
Генерирует событие и передает данные. Эти данные попадают в функцию-обработчик методе on().

Основное отличие от браузерных событий в том что браузерные обработчики выполняются в произвольном порядке, а
нодовские в точности в том порядке в котором были назначены.
Ещё одно отличие в том что в браузере мы никак не сможем получить список обработчиков, которые назначены
на определенный элемент, а в node.js это легко сделать через
 - emitter.listeners(event) - возвращает все обработчики назначенные на данное событие.
 - EventEmitter.listenerCount(emitter, event) - возвращает общее кол-во обработчиков.

==========================================================================================================
Следующее отличие в том что EventEmitter специальным образом описывают события с названием error.
Если где-либо происходит эмит этого события и у него нет обработчика, то EventEmitter генерирует исключения или
exception. Из-за чего такой эмит повалит весь процесс. Исключения генерируются встроенного типа
throw TypeError. А если есть объект ошибки в аргументах, то этот аргумент будет использован в качестве аргумента throw.
===================================================================================================================

Память вырастает и потом очищается. Это нормально, т.к. request это локальная переменная данной функции и после
окончания функции она нигде не сохраняется.

У EventEmitter есть максимальное число обработчиков = 10. Если больше то ворнинг.
Мы можем отключить максимальное кол-во обработчиков через db.setMaxListeners(0)
Предполагая что много кто может подписываться на эти события и при этом нельзя забывать убирать обработчики
===============================================================================================================













1) Создать класс-наследник от EventEmitter. Прописать логику внутри класса и снаружи(создать метод, который принимает
в параметры функцию, которая печатает предложение - Выполняется задание). Затем создать объект этого класса и навешать
другие обработчики чтобы при запуске вашего файла выводились такие предложения
     Перед выполнением
     О выполнении
     Выполняется задание
     Готово с исполнением
     После исполнения

2)Создать любой ивент, загрузить через него любой сайт и вывести загруженный сайт на консольку