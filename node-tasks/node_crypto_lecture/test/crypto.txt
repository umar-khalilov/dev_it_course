Криптография - от древнегреческого скрытое или секретная писанина. Наука о методах обеспечения конфиденциальности,
целостности данных, аутентификации(проверка подлинности авторства), шифрования(кодировка данных).
Шифрования информации — обратимое преобразования открытого (исходного) текста на основе секретного алгоритма
или ключа в шифрованный текст (шифротекст). Традиционная криптография образует раздел симметричных криптосистем,
в которых зашифровывание и расшифровывание проводится с использованием одного и того же секретного ключа.
Шифрование — процесс нормального применения криптографического преобразования открытого текста на основе алгоритма и
 ключа, в результате которого возникает шифрованный текст.
Расшифровывание — процесс нормального применения криптографического преобразования шифрованного текста в открытый.
Распространённые алгоритмы шифрования: симметричные DES, AES, ГОСТ 28147-89, Camellia, Twofish, Blowfish, IDEA, RC4 и др.;
                                      асимметричные RSA и Elgamal (Эль-Гамаль);
                                      хеш-функций MD4, MD5, MD6, SHA-1, SHA-2, ГОСТ Р 34.11-2012 («Стрибог»).

Хэш - это строка битов фиксированной длины, которая процедурно и детерминированно генерируется из некоторого
произвольного блока исходных данных. Некоторые важные свойства этих хэшей (тип, полезный для криптографии) включают:

Фиксированная длина: это означает, что независимо от того, какой вводится, длина хеша одинакова. Например,
хэши SHA-256 всегда имеют длину 256 бит, независимо от того, составляют ли входные данные несколько бит или несколько гигабайт.

Детерминированный: для одного и того же ввода вы должны рассчитывать точно такой же хэш. Это делает хэши
полезными для контрольных сумм.

Устойчивость к коллизиям : коллизия возникает, когда один и тот же хэш генерируется для двух разных входных блоков
 данных. Алгоритмы хеширования разработаны таким образом, чтобы исключить вероятность возникновения коллизий -
 насколько маловероятно это свойство алгоритма хеширования. Важность этого свойства зависит от варианта использования.

Однонаправленный: хороший алгоритм хеширования легко применить, но его трудно отменить. Это означает, что с учетом
хэша нет разумного способа узнать, каковы были исходные данные.

Алгоритмы хеширования, которые работают с криптовалютой
Хеши, которые работают с криптографией, зависят от того, что поддерживает ваша версия OpenSSL. Если у вас достаточно
новая версия OpenSSL, вы можете получить список хеш-типов, поддерживаемых вашим OpenSSL, введя его openssl
list-message-digest-algorithmsв командной строке. Для более старых версий просто введите openssl
list-message-digest-commandsвместо этого!

Один из наиболее распространенных алгоритмов хеширования - SHA-256. Старые популярные типы, такие как SHA-1
 или MD5, больше не являются безопасными и не должны использоваться.

Как рассчитать хеши с помощью криптографии
У Crypto есть метод, createHash который позволяет вычислить хэш. Его единственный аргумент - строка, представляющая
    хеш. В этом примере выполняется поиск хэша SHA-256 для строки «Боже мой, я люблю узел!»:
    require("crypto")
      .createHash("sha256")
      .update("Man oh man do I love node!")
      .digest("hex");

update Метод используется для передачи данных, чтобы позже быть превращены в хэш с digest методом. update может быть
вызван несколько раз для приема потоковых данных, например буферов из потока чтения файлов. Аргумент для
digest представляет формат вывода и может быть двоичным, шестнадцатеричным или base64. По умолчанию используется
двоичный файл.

HMAC расшифровывается как Hash-based Message Authentication Code(Код аутентификации сообщений на основе хэша) и
представляет собой процесс применения
хеш-алгоритма как к данным, так и к секретному ключу, что приводит к единому окончательному хешу. Его
использование похоже на использование ванильного хэша, но также позволяет проверять подлинность данных, а
также целостность указанных данных (как вы можете использовать контрольные суммы SHA-256).

API для hmacs очень похож на API, за createHash исключением того, что вызывается метод, createHmac и он принимает
 ключ в качестве второго аргумента:
require("crypto").createHmac("sha256", "password").update("If you love node so much why don't you marry it?")
  .digest("hex");
  Результирующий хэш SHA-256 уникален как для входных данных, так и для ключа.

  Шифры
  Шифры позволяют кодировать и декодировать сообщения по паролю.

  Шифровальные алгоритмы, работающие с криптографией
  Как и алгоритмы хеширования криптографии, шифры, которые работают с криптографией, зависят от того, что поддерживает
  ваша версия OpenSSL. Вы можете получить список типов хэшей, поддерживаемых вашим OpenSSL, введя openssl
  list-cipher-commandsв командной строке для более старых версий или openssl list-cipher-algorithmsдля более
  новых версий OpenSSL. OpenSSL поддерживает множество шифров; Хороший и популярный - AES_256.

  Как использовать алгоритмы шифрования с криптовалютой:
  Crypto имеет два метода шифрования и дешифрования:

  crypto.createCipheriv(algorithm, key, iv)
  crypto.createDecipheriv(algorithm, key, iv)
  Оба эти метода принимают аргументы аналогично createHmac. У них обоих аналогичные update функции. Однако каждое
  использование update возвращает фрагмент закодированных / декодированных данных вместо того, чтобы вызывать его
   digest для получения результата. Более того, после кодирования (или декодирования) ваших данных вам, вероятно,
   придется вызвать final метод, чтобы получить последний фрагмент закодированной информации.

  Еще одно важное дополнение в методе шифрования - вектор инициализации iv or. Векторы инициализации должны быть
  непредсказуемыми и уникальными, обычно требуется, чтобы они были случайными или псевдослучайными. Рандомизация
  имеет решающее значение для схем шифрования для достижения семантической безопасности, свойства, посредством
  которого повторное использование схемы с одним и тем же ключом не позволяет злоумышленнику сделать вывод о
  взаимосвязях между сегментами зашифрованного сообщения.

  Единый ключ для шифрования и дешифрования, называемый симметричным шифрованием.
  Один ключ для шифрования и другой для дешифрования; также называется асимметричным шифрованием
  Алгоритмы шифрования
  DES преобразует 64-битные блоки данных открытого текста в зашифрованный текст путем разделения на два отдельных
   32-битных блока, применяя процесс шифрования к каждому отдельно. Включает в себя 16 циклов различных
   процессов — таких как расширение, перестановка, замена или другие операции — через которые будут проходить
    данные в зашифрованном виде. В конечном итоге 64-битные блоки зашифрованного текста создаются в качестве
    выходных данных. Самым большим недостатком DES была слишком маленькая длина ключа шифрования, что облегчало взлом.

2. Алгоритм симметричного шифрования 3DES
3DES также известный как TDEA (triple data encryption algorithm), как следует из названия, является обновленной
 версией алгоритма DES. 3DES был разработан для преодоления недостатков алгоритма DES и был введен в эксплуатацию
 в конце 1990 года. Обновленный алгоритм применял циклы DES трижды к каждому блоку данных. В результате 3DES было
 намного сложнее взломать, чем его предшественника DES. TDEA стал широко используемым алгоритмом шифрования в платежных
  системах и других технологиях финансовой индустрии. Он также стал частью криптографических протоколов, таких
  как TLS, SSH, IPsec и OpenVPN.

  3. Алгоритм симметричного шифрования AES
  AES(advanced encryption system) также известный как Rijndael, является одним из наиболее распространенных
  алгоритмов шифрования. Был разработан в качестве альтернативы DES и после утверждения NIST в 2001 году стал
  новым стандартом шифрования. AES — это семейство блочных шифров с различной длиной ключей и разными размерами блоков.

1. Алгоритм асимметричного шифрования RSA
В 1977 году алгоритм изобрели трое ученых из Массачусетского технологического института Рон Ривест, Ади Шамир и
 Леонард Адлеман (Ron Rivest, Adi Shamir, and Leonard Adleman отсюда «RSA»). На сегодняшний день является наиболее
  используемым алгоритмом асимметричного шифрования. Его эффективность заключается в методе «первичной факторизации».
   По сути, выбираются два различных случайных простых числа заданного размера (например, 1024 бита каждое) и
   умножаются, чтобы создать еще одно гигантское число. Задача состоит в том, чтобы определить исходные простые
   числа из умноженного гигантского. Оказывается, эта головоломка практически невозможна для современных
   суперкомпьютеров, не говоря уже о людях.
В 2010 году группа добровольцев провела исследование, и им потребовалось более 1500 лет вычислительного времени
(распределенного по сотням компьютеров), чтобы взломать 768-битный ключ RSA, что намного ниже стандартного
2048-битного, который используется сегодня.
Большим преимуществом RSA является его масштабируемость, ключи могут быть разной длины шифрования: 768-битный,
 1024-битный, 2048-битный, 4096-битный и т. д.

 2. Алгоритм асимметричного шифрования ECC
 Как и RSA, ECC также работает по принципу необратимости. Проще говоря, в ECC число, символизирующее точку на кривой,
 умножается на другое число и дает другую точку на кривой. Теперь, чтобы взломать эту головоломку, вы должны выяснить
 новую точку на кривой. Математика ECC построена таким образом, что найти новую точку практически невозможно, даже
 если вы знаете исходную точку.
Не смотря на то, что по сравнению с RSA, в ECC используется более короткая длина ключа обеспечивает он большую
безопасность (от современных методов взлома).
Еще одним преимуществом использования более коротких ключей в ECC является более высокая производительность.


  Вот пример, немного менее тривиальный, чем предыдущие примеры, который использует криптовалюту и yargs для
  кодирования и декодирования сообщений из командной строки:
